<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="博客,个人博客,技术博客,ldk,ldkblog,ldkblog.com,后端,IT"><meta name="description" content="LDK&#39;s Blog"><meta name="author" content="LDK"><title>std::future, std::promise与std::async | LDK&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/img/avatar.png"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><link rel="stylesheet" href="/css/custom.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"ldk-blog.cn",root:"/",language:"zh-CN"},KEEP.theme_config={base_info:{primary_color:"#0044aa",title:"LDK's Blog",author:"LDK",avatar:"/img/avatar.png",logo:"/images/avatar.svg",favicon:"/img/avatar.png"},menu:{home:"/ || fa-solid fa-house",archives:"/archives || fa-solid fa-box-archive",tags:"/tags || fa-solid fa-tags",categories:"/categories || fa-solid fa-layer-group",about:"/about || fa-solid fa-user-graduate"},first_screen:{enable:!0,background_img:"/background/013_up.webp",background_img_dark:"/images/bg.svg",description:"Keep writing and Keep loving.",hitokoto:!1},social_contact:{enable:!0,links:{github:"https://github.com/LiDaoKuan",weixin:"img | /img/wechat.jpg",qq:"/img/qq.jpg",twitter:null,x:null,facebook:null,email:"3375858506@qq.com"}},scroll:{progress_bar:!0,percent:!1,hide_header:!0},home:{announcement:"本博客因为部署在netlify, 所以可能会出现部分图片加载不出来的情况。如有必要请科学上网！",category:!0,tag:!0,post_datetime:"updated || fa-regular fa-clock fa-spin"},post:{author_badge:{enable:!0,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD",copyright_info:!0,share:!1,reward:{enable:!1,img_link:null,text:null,icon:null}},img_align:"center",code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"obsidian"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!0,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!1,preload:!1},comment:{enable:!1,use:"valine",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.39"},waline:{server_url:null,reaction:!1,version:"3.3.2"},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!1},lazyload:{enable:!0},cdn:{enable:!1,provider:"cdnjs"},pjax:{enable:!0},footer:{since:2024,word_count:!0,site_deploy:{enable:!0,provider:"vercel",url:null},record:{enable:!1,list:[{code:null,link:null}]}},inject:{enable:!0,css:["/css/custom.css"],js:[null]},root:"",source_data:{links:[{title:"友链分组1"},{name:"XPoet",link:"https://xpoet.cn",description:"懒惰是程序员第一生产力",avatar:"https://xpoet.cn/images/avatar.png"},{name:"不知名艺术家",link:"https://jinzhanqi.com/",description:"love artist, love code.",avatar:"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"}]},version:"4.2.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},KEEP.language_code_block={copy:"复制代码",copied:"已复制",fold:"折叠代码块",folded:"已折叠"},KEEP.language_copy_copyright={copy:"复制版权信息",copied:"已复制",title:"原文标题",author:"原文作者",link:"原文链接"}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left flex-start border-box"><a class="logo-image border-box" href="/"><img src="/images/avatar.svg"> </a><a class="site-name border-box" href="/">LDK&#39;s Blog</a></div><div class="right border-box"><div class="pc border-box"><ul class="menu-list border-box"><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/"><i class="menu-text-color menu-icon fa-solid fa-house"></i> 首页</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/archives"><i class="menu-text-color menu-icon fa-solid fa-box-archive"></i> 归档</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/tags"><i class="menu-text-color menu-icon fa-solid fa-tags"></i> 标签</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/categories"><i class="menu-text-color menu-icon fa-solid fa-layer-group"></i> 分类</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/about"><i class="menu-text-color menu-icon fa-solid fa-user-graduate"></i> 关于</a></li></ul></div><div class="mobile border-box flex-start"><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list border-box"><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/"><span class="menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color menu-icon fa-solid fa-house"></i> </span>首页</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/archives"><span class="menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i> </span>归档</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/tags"><span class="menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i> </span>标签</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/categories"><span class="menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i> </span>分类</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/about"><span class="menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color menu-icon fa-solid fa-user-graduate"></i> </span>关于</a></label></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><div class="post-title">std::future, std::promise与std::async</div><div class="post-header border-box"><div class="avatar-box border-box"><img src="/img/avatar.png"></div><div class="info-box"><div class="author border-box"><span class="name">LDK</span> <span class="author-badge">Lv5</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2025-08-06</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="datetime" data-updated="Sun Jan 25 2026 21:03:42 GMT+0800">2026-01-25</span> </span><span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;<ul class="post-category-ul"><li class="category-item"><a href="/categories/Cpp/">Cpp</a></li></ul></span><span class="post-tag meta-info-item border-box"><ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Cpp/">Cpp</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li></ul></span><span class="meta-info-item post-wordcount"><i class="icon fas fa-file-word"></i>&nbsp;<span>2.4k 字</span> </span><span class="meta-info-item post-min2read"><i class="icon fas fa-clock"></i>&nbsp;<span>10 分钟</span> </span><span class="meta-info-item post-pv"><i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h3 id="std-async">std::async</h3><p><code>std::async</code>是一个用于异步执行函数的模板函数，它返回一个 <code>std::future</code> 对象，该对象用于获取执行函数的返回值。关于<code>std::future</code>的具体细节，此处可以先忽略，只要能够看懂实例程序就行。</p><p>其函数声明余如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Fn, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">_GLIBCXX_NODISCARD future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt; <span class="built_in">async</span>(std::launch __policy, _Fn &amp;&amp;__fn, _Args &amp;&amp;...__args);</span><br></pre></td></tr></table></figure><p>由函数声明可以看出：该函数接收多个参数，其中<strong>第一个参数是启动策略</strong>，<strong>第二个函数是要执行的函数</strong>，剩下的参数就是执行函数需要的参数。</p><p>其中关于第一个参数：启动策略，可选值有：</p><ul><li><code>std::launch::async</code>：保证异步行为，即传递函数将在单独的线程中执行。推荐使用。</li><li><code>std::lanuch::deferred</code>：执行函数将在调用<code>std::future::get()</code>或<code>std::future::wait()</code>时延迟执行（同步执行）。换句话说，执行函数将在需要结果时同步执行。</li><li><code>std::launch::async | std::launch::deferred</code>：在不指定启动策略时，默认的启动策略。执行函数可能同步执行，也可能异步执行。</li></ul><p>使用举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务，比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fetchDataFromDB finished&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFuture = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else in main thread ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFuture.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Doing something else in main thread ...</span><br><span class="line">fetchDataFromDB finished</span><br><span class="line">Data: Data</span><br></pre></td></tr></table></figure><p><code>std::async</code>实际上是在执行函数时，传入了一个<code>std::promise</code>，然后单开一个线程执行，同时返回关联的<code>std::future</code>。方便外部获取结果。</p><h3 id="std-future和std-promise">std::future和std::promise</h3><h4 id="std-future">std::future</h4><h5 id="用途">用途</h5><p><code>std::future</code>提供了访问异步操作结果的机制。<code>future</code>在中文中的意思就是&quot;期望&quot;。在C++中，有两种&quot;期望&quot;：</p><ul><li>唯一期望（<code>unique futures</code>）：<code>std::future&lt;&gt;</code>。只能与一个指定事件关联。</li><li>共享期望（<code>shared futures</code>）： <code>std::shared_future&lt;&gt;</code>。能够关联多个事件。</li></ul><p>实际上，<code>std::future</code>内部存储了一个将会被某个<code>promise</code>赋值的变量，并提供了访问该值的<code>get()</code>函数。如果<code>get()</code>函数被调用时，<code>promise</code>尚未赋值（<code>set_value()</code>），那么调用者线程将会阻塞等待，直到<code>promise</code>完成赋值。</p><p>正常情况下，<code>std::future</code>对象通常由一下三种方式创建或得到：</p><ul><li><p><code>std::async</code>函数的返回值。上文已经讲过。</p></li><li><p><code>std::promise::get_future</code>函数。而调用该函数前肯定需要创建一个<code>promise</code>对象：</p><p><code>std::promise&lt;int&gt; promiseObj; // 创建一个promise对象，任务完成后设置int值</code></p></li><li><p><code>std::packaged_task::get_future</code>函数。</p></li></ul><p>其实<code>std::future</code>的构造函数是能用的（拷贝构造除外）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="built_in">future</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// copy [deleted] </span></span><br><span class="line"><span class="built_in">future</span> (<span class="type">const</span> future&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// move</span></span><br><span class="line"><span class="built_in">future</span> (future&amp;&amp; x) <span class="keyword">noexcept</span>;s</span><br></pre></td></tr></table></figure><h5 id="std-future的状态">std::future的状态</h5><p>对一个<code>std::future</code>对象，存在有共享状态和无共享状态两种情况。</p><blockquote><p>有共享状态：可用，可以调用<code>get()</code>函数。</p><p>无共享状态：不可用，此时调用<code>get()</code>函数会抛出异常。</p></blockquote><p>有共享状态时又分为三种：<code>future_status::ready</code>，<code>future_status::timeout</code>和<code>future_status::deferred</code>。</p><p><code>future_status::ready</code>：共享状态的标志已经变为<code>ready</code>，即对应的<code>std::promise</code>在共享状态上设置了值或者异常。</p><p><code>future_status::timeout</code>：超时，即在规定的时间内共享状态的标志没有变为<code>ready</code>。</p><p><code>future_status::deferred</code>：共享状态包含一个<code>deferred</code>函数。</p><h5 id="成员函数">成员函数</h5><ul><li><p><code>std::future::valid()</code>：</p><p>判断<code>std::future</code>是否拥有共享状态。可以简单理解为是否有效。主要用于应对下面两种情况：</p><ul><li><p>因为<code>std::future</code>是可移动的，所以在对象被<code>std::move</code>后，原对象会无效，也就是不可用（无共享状态），此时对原对象调用<code>get()</code>成员函数将会导致程序抛出异常。例如下面的程序段：</p><p><code>std::future&lt;int&gt; futureObj_move = std::move(futureObj); futureObj_move.get(); // 会抛出异常</code></p></li><li><p>当<code>future</code>对象调用<code>get()</code>函数之后，该对象将变得无效（无共享状态）。再次调用<code>get()</code>都会导致程序抛出异常。例如：</p><p><code>int sum = futureObj.get(); sum = futureObj.get();</code></p><p>连续调用两次<code>get()</code>函数，第二次会抛出异常。</p></li></ul><p>以上两种情况，都可以用<code>valid()</code>来检测：<br><code>if (futureObj.valid()) &#123; sum = futureObj.get(); &#125;</code></p><p>这样就可以避免抛出异常。当然多线程时，这里还要考虑线程安全问题。</p></li><li><p><code>std::future::get()</code>：</p><p>阻塞式获得共享状态的值，如果 <code>future</code> 对象调用 <code>get()</code> 时，共享状态标志尚未被设置为 <code>ready</code>，那么本线程将阻塞至其变为 <code>ready</code>。</p></li><li><p><code>std::future::wait()</code>：</p><p>阻塞等待共享状态标志变为<code>ready</code>，如果在无共享状态下调用（<code>valid()</code>函数返回<code>false</code>），将会抛出异常。</p></li><li><p><code>std::future::wait_for()</code>：</p><p>与<code>wait()</code>不同，<code>wait_for()</code>只会允许为此等待一段时间<code>_Rel_time</code>，耗尽这个时间共享状态标志仍不为<code>ready</code>，<code>wait_for()</code>一样会返回。</p></li><li><p><code>std::future::wait_until()</code>：</p><p>与<code>wait_for()</code>类似的逻辑，只不过<code>wait_until()</code>参考的是绝对时间点。到达时间点<code>_Abs_time</code>的时候，<code>wait_until()</code>就会返回，如果没等到<code>ready</code>的话，<code>wait_until</code>一样会返回。</p></li><li><p><code>std::future::share()</code>：</p><p>返回一个<code>std::shred_future</code>对象，调用该函数之后，<code>future</code>对象不和任何共享状态关联，也就不再是<code>valid</code>的了。例如：</p><p><code>futureObj.share(); int sum = futureObj.get();</code></p><p>后面一句会报错，因为前面使用了<code>share()</code>，<code>futureObj</code>已经不再有效。</p></li></ul><h4 id="std-promise">std::promise</h4><p><code>std::promise</code>的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的<code>future</code>， 即使这个<code>future</code>与<code>promise</code>不在同一个线程中也可以安全的访问到这个值。</p><p>可以通过<code>get_future()</code>来获取与一个<code>promise</code>对象相关联的<code>future</code>对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。</p><p><code>set_value()</code>函数可以设置共享状态的值，此后<code>promise</code>的共享状态标志变为<code>ready</code>。每个<code>std::promise</code>只能调用一次<code>set_value()</code>。</p><p><code>set_exception()</code>函数可以设置异常，在这之后对与之相关联的<code>std::future</code>的<code>get()</code>调用将抛出这个异常。</p><h4 id="简单使用案例：">简单使用案例：</h4><p>主要是<code>std::promise</code>的值传递问题。</p><p>版本一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">//std::future std::promise</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, std::promise&lt;<span class="type">int</span>&gt; promiseObj)</span> <span class="comment">// 注意最后一个参数是普通传参，没有引用也没有指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">pow</span>(x, y); ++i) &#123;</span><br><span class="line">        sum += i; <span class="comment">// 模拟复杂任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    promiseObj.<span class="built_in">set_value</span>(sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value has been set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个promise类</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">    <span class="comment">// 将future和promise关联</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(fun, a, b, std::move(promiseObj))</span></span>; <span class="comment">// 此处必须使用std::move</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的&quot;返回值&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ready to get value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> sum = futureObj.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum=&quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出：18</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span>  <span class="comment">//std::future std::promise</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, std::promise&lt;<span class="type">int</span>&gt;&amp; promiseObj)</span> <span class="comment">// 注意此处promise是引用传参！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">pow</span>(x, y); ++i) &#123;</span><br><span class="line">        sum += i; <span class="comment">// 模拟复杂任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    promiseObj.<span class="built_in">set_value</span>(sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value has been set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个promise类</span></span><br><span class="line">	std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">	<span class="comment">// 将future和promise关联</span></span><br><span class="line">	std::future&lt;<span class="type">int</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(fun, a, b, std::ref(promiseObj))</span></span>; <span class="comment">// 此处必须用std::ref</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取线程的&quot;返回值&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ready to get value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> sum = futureObj.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum=&quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出：18</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本三：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">//std::future std::promise</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, std::promise&lt;<span class="type">int</span>&gt;* promiseObj)</span> <span class="comment">// 注意此处传递的是指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">pow</span>(x, y); ++i) &#123;</span><br><span class="line">        sum += i; <span class="comment">// 模拟复杂任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    promiseObj-&gt;<span class="built_in">set_value</span>(sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value has been set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个promise类</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">    <span class="comment">// 将future和promise关联</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(fun, a, b, &amp;(promiseObj))</span></span>; <span class="comment">// 注意此处直接取地址！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的&quot;返回值&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ready to get value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> sum = futureObj.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum=&quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出：18</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会有三种版本，对应三种不同的传值方式呢？本质是因为<code>std::promise</code>不可拷贝（拷贝函数被删除），但可以移动（移动构造可用）。</p><table><thead><tr><th>特性</th><th style="text-align:center">版本一（值传递+move）</th><th style="text-align:center">版本二（引用传递+ref）</th><th style="text-align:center">版本三（指针传递）</th></tr></thead><tbody><tr><td><strong>promise变量的所有权</strong></td><td style="text-align:center">完全转移给线程函数</td><td style="text-align:center">共享（主线程保持所有权）</td><td style="text-align:center">共享（主线程保持所有权）</td></tr><tr><td><strong>生命周期</strong></td><td style="text-align:center">线程函数负责销毁</td><td style="text-align:center">主线程负责销毁</td><td style="text-align:center">主线程负责销毁</td></tr><tr><td><strong>内存安全</strong></td><td style="text-align:center">✅ 最安全（无悬空引用风险）</td><td style="text-align:center">⚠️ 需要正确同步</td><td style="text-align:center">⚠️ 需要正确同步</td></tr><tr><td><strong>代码清晰度</strong></td><td style="text-align:center">✅ 最清晰（明确所有权转移）</td><td style="text-align:center">✅ 良好</td><td style="text-align:center">❌ 较低（C风格）</td></tr><tr><td><strong>标准推荐</strong></td><td style="text-align:center">✅ 首选</td><td style="text-align:center">✅ 可接受</td><td style="text-align:center">❌ 不推荐</td></tr></tbody></table></div><div class="post-copyright-info-container border-box"><div class="copyright-info-content border-box"><div class="copyright-info-top border-box"><div class="copyright-post-title border-box text-ellipsis">std::future, std::promise与std::async</div><div class="copyright-post-link border-box text-ellipsis">undefined/C-Plus-Plus/c-plus-plus-11/std::future与std::promise/</div></div><div class="copyright-info-bottom border-box"><div class="copyright-post-author bottom-item"><div class="type">作者</div><div class="content">LDK</div></div><div class="post-time bottom-item"><div class="type">发布于</div><div class="content">2025-08-06 00:00</div></div><div class="post-license bottom-item"><div class="type">许可</div><div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank"><i class="fa-brands fa-creative-commons"></i> <i class="fa-brands fa-creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc"></i> <i class="fa-brands fa-creative-commons-sa"></i></a></div></div></div><i class="copyright-bg fa-solid fa-copyright"></i></div><div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Cpp/">Cpp</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li></ul></div><div></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/undefined/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/epoll%E7%9A%84LT%E6%A8%A1%E5%BC%8F%E5%92%8CET%E6%A8%A1%E5%BC%8F/" title="epoll的LT模式和ET模式"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">epoll的LT模式和ET模式</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/undefined/C-Plus-Plus/c-plus-plus-11/std::packaged_task/" title="std::packaged_task"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">std::packaged_task</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-async"><span class="nav-text">std::async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-future%E5%92%8Cstd-promise"><span class="nav-text">std::future和std::promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-future"><span class="nav-text">std::future</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-text">用途</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-future%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">std::future的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-promise"><span class="nav-text">std::promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-text">简单使用案例：</span></a></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="copyright-info info-item">&copy;&nbsp;<span>2024</span>&nbsp;-&nbsp;2026 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">LDK</a></div><div class="theme-info info-item">由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="deploy-info info-item">本站由 <span class="tooltip" data-tooltip-content="Vercel"><img src="/images/brands/vercel.png"></span>提供部署服务</div><div class="count-info info-item"><span class="count-item border-box word"><span class="item-type border-box">总字数</span> <span class="item-value border-box word">77.4k</span> </span><span class="count-item border-box uv"><span class="item-type border-box">访客数</span> <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span> </span><span class="count-item border-box pv"><span class="item-type border-box">访问量</span> <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span></span></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="post-tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-async"><span class="nav-text">std::async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-future%E5%92%8Cstd-promise"><span class="nav-text">std::future和std::promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-future"><span class="nav-text">std::future</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-text">用途</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-future%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">std::future的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-promise"><span class="nav-text">std::promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-text">简单使用案例：</span></a></li></ol></li></ol></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/lazyload.js"></script><div class="pjax"><script src="/js/post/post-helper.js"></script><script src="/js/post/toc.js"></script><script src="/js/post/copyright-info.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script></body></html>